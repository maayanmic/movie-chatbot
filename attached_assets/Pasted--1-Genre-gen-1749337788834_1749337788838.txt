תהליך הסינון הספציפי:

כל הפילטרים הזמינים:
1. פילטר ז'אנר (Genre)
# מיפוי חכם למסד הנתונים
genre_mapping = {
    'romance': 'romantic',
    'comedy': 'comedies', 
    'drama': 'dramas',
    'action': 'action',
    'horror': 'horror'
}
דוגמאות: "סרטי אקשן", "קומדיות", "סרטים רומנטיים"

2. פילטר שנת יציאה (Year Range)
year_mask = (filtered['released'] >= min_year) & (filtered['released'] <= max_year)
דוגמאות: "משנות ה-90", "סרטים מ-2020 עד 2023", "סרטים חדשים"

3. פילטר קבוצת גיל (Age Group)
age_mask = filtered['age_group'] == params['age_group']
אפשרויות: Kids, Teens, Young Adults, Adults
דוגמאות: "סרטים לילדים", "סרטים למבוגרים"

4. פילטר משך זמן (Runtime)
if operator == 'less_than':
    runtime_mask = filtered['runtime'] <= runtime
elif operator == 'greater_than':
    runtime_mask = filtered['runtime'] >= runtime
elif operator == 'equal_to':
    runtime_mask = (filtered['runtime'] >= runtime - 10) & (filtered['runtime'] <= runtime + 10)
דוגמאות: "סרטים קצרים מ-90 דקות", "סרטים ארוכים מ-2 שעות"

5. פילטר שחקנים (Cast)
actor_mask = filtered['cast'].str.contains(actor, case=False, na=False)
דוגמאות: "סרטים עם ברד פיט", "סרטים עם ג'ניפר לורנס"

6. פילטר במאי (Director)
director_mask = filtered['director'].str.contains(director, case=False, na=False)
דוגמאות: "סרטים של כריסטופר נולאן", "סרטים של קוונטין טרנטינו"

7. פילטר מדינה (Country)
country_mask = filtered['country'].str.contains(country, case=False, na=False)
דוגמאות: "סרטים אמריקאיים", "סרטים צרפתיים", "סרטים יפניים"





8. פילטר תיאור עלילה (Description Keywords)
for keyword in keywords:
    keyword_mask = filtered['description'].str.contains(keyword, case=False, na=False)
    filtered.loc[keyword_mask, 'keyword_score'] += 1
דוגמאות: "סרט על רופא נעדר", "סרט על חטיפה", "סרט על מלחמה"

9. פילטר פופולריות (Popular)
# ציון 1-5 במסד הנתונים
popular_mask = filtered['popular'] >= threshold
דוגמאות: "סרטים פופולריים", "סרטים בדירוג גבוה"
תהליך הסינון המדורג:
def filter_movies(self, params):
    # התחלה עם כל הסרטים (5,371)
    filtered = self.movies.copy()
    
    # פילטר 1: ז'אנר
    if params.get('genre'):
        filtered = filtered[genre_mask]
    
    # פילטר 2: שנה
    if params.get('year_range'):
        filtered = filtered[year_mask]
    
    # פילטר 3: קבוצת גיל
    if params.get('age_group'):
        filtered = filtered[age_mask]
    
    # פילטר 4: משך זמן
    if params.get('runtime'):
        filtered = filtered[runtime_mask]
    
    # פילטר 5: שחקן
    if params.get('actor'):
        filtered = filtered[actor_mask]
    
    # פילטר 6: במאי
    if params.get('director'):
        filtered = filtered[director_mask]
    
    # פילטר 7: מדינה
    if params.get('country'):
        filtered = filtered[country_mask]
    
    # פילטר 8: תיאור עלילה
    if params.get('description_keywords'):
        filtered = filtered[keyword_score > 0]
    
    # דירוג ותוצאות (מקסימום 6 סרטים)
    return filtered.head(6)







דוגמאות לשילוב פילטרים:
פשוט:
•	"סרטי אקשן" → רק פילטר ז'אנר
בינוני:
•	"סרטי אקשן אמריקאיים" → ז'אנר + מדינה
מורכב:
•	"סרטי אקשן אמריקאיים עם ברד פיט משנות ה-90 קצרים מ-2 שעות"
→ ז'אנר + מדינה + שחקן + שנה + משך זמן
המערכת מפעילה את כל הפילטרים במקביל ומחזירה רק סרטים שעומדים בכל הקריטריונים שצוינו.
הגדרת חיפוש כללי ולא ספציפי:


is_specific_search = bool(params.get('description_keywords'))
# אם אין מילות מפתח בתיאור = חיפוש כללי
תהליך הדירוג לחיפוש כללי:
1. ערבוב אקראי לגיוון:
if not is_specific_search:
    import random
    random.seed()
    filtered = filtered.sample(frac=1).reset_index(drop=True)

מטרה: למנוע תוצאות זהות בכל חיפוש
2. ציון משולב:
filtered['combined_score'] = (0.7 * filtered['popular']) + (0.3 * (filtered['released'] - 2000) / 24)
filtered = filtered.sort_values('combined_score', ascending=False)

פירוט הציון:
•	70% פופולריות (1-5) מהדירוגים במסד הנתונים
•	30% עדכניות (סרטים חדשים יותר מקבלים ציון גבוה יותר)
3. דוגמאות לחיפוש כללי:
שאילתה: "סרטי אקשן"
# פילטר: רק ז'אנר אקשן
# דירוג: פופולריות + עדכניות
# תוצאה: סרטי האקשן הפופולריים והחדשים ביותר
שאילתה: "סרטים אמריקאיים משנות ה-90"
# פילטר: מדינה + שנה
# דירוג: פופולריות של סרטים משנות ה-90
# תוצאה: הסרטים הפופולריים ביותר מאותה תקופה
השוואה: כללי vs ספציפי
חיפוש כללי	חיפוש ספציפי
"סרטי קומדיה"	"סרט על רופא נעדר"
דירוג: פופולריות	דירוג: פופלריות
גיוון אקראי	סדר קבוע
מתמקד בסרטים טובים	מתמקד בהתאמה לעלילה
המטרה:
חיפוש כללי נועד לתת המלצות איכותיות מתוך הקטגוריה הרצויה, תוך שמירה על גיוון ועדכניות.
כשאת מבקשת "סרט רומנטי" - זה מה שקורה:
שלב 1 - זיהוי פרמטרים:
# Gemini מזהה:
{
  "genre": "Romance",
  "description_keywords": null  # אין תיאור ספציפי
}
שלב 2 - קביעת סוג חיפוש:
is_specific_search = bool(params.get('description_keywords'))
# description_keywords = null → is_specific_search = False
# זה חיפוש כללי!
שלב 3 - פילטור:
# מיפוי ז'אנר
'romance' → 'romantic'  # התאמה למסד הנתונים
 
# פילטר
genre_mask = filtered['genre'].str.contains('romantic', case=False)
filtered = filtered[genre_mask]
 
# תוצאה: כל הסרטים הרומנטיים (נאמר 350 סרטים)
שלב 4 - דירוג כללי:
# ערבוב אקראי
filtered = filtered.sample(frac=1)
 
# ציון משולב
combined_score = (0.7 × popular) + (0.3 × חדשות)
 
# דירוג
filtered.sort_values('combined_score', ascending=False)
 
# תוצאה: 6 הסרטים הרומנטיים הטובים והחדשים ביותר
תוצאה סופית:
המערכת תחזיר את הסרטים הרומנטיים הפופולריים ביותר מהמסד נתונים, תוך שמירה על גיוון (בגלל הערבוב האקראי) והעדפה לסרטים חדשים יותר.
דוגמה למה שתקבלי:
•	The Notebook (2004) - דירוג 5/5
•	Titanic (1997) - דירוג 5/5
•	Pride and Prejudice (2005) - דירוג 4/5
•	La La Land (2016) - דירוג 4/5
כל אלה סרטים רומנטיים איכותיים מהמסד נתונים, מדורגים לפי פופולריות ועדכניות.









כן! הקוד מכיל מספר טכניקות שקשורות ל-clustering ו-similarity שלמדת בקורס:
1. Similarity Matching (דמיון)
Fuzzy String Matching:
def fuzzy_match(self, word, target_words, threshold=0.7):
    # רגיע... דמיון רצף
    similarity = difflib.SequenceMatcher(None, word_lower, target_lower).ratio()
    if similarity >= threshold:
        return True
זה מחשב דמיון בין מחרוזות באמצעות Sequence Similarity.
Content-Based Similarity:
# חיפוש במילות מפתח בתיאור
keyword_mask = filtered['description'].str.contains(keyword, case=False, na=False)
זה מוצא דמיון בתוכן הסרטים על בסיס מילות מפתח.
2. Scoring & Ranking (דירוג רלוונטיות)
Relevance Scoring:
filtered['keyword_score'] = 0
# מעלה ניקוד לכל מילת מפתח שנמצאת
filtered.loc[keyword_mask, 'keyword_score'] += 1
Combined Scoring:
# ניקוד משולב של פופולריות ושנה
filtered['combined_score'] = (0.7 * filtered['popular']) + (0.3 * (filtered['released'] - 2000) / 24)
3. Feature-Based Clustering
Multi-Dimensional Filtering:
הקוד מקבץ סרטים לפי תכונות:
•	ז'אנר - genre filtering
•	שנה - year_range filtering
•	קהל יעד - age_group filtering
•	זמן ריצה - runtime filtering
•	תוכן - description keywords
Smart Sorting by Search Type:
if is_specific_search:
    # מיון לפי רלוונטיות למילות מפתח
    filtered = filtered.sort_values(['keyword_score', 'popular', 'released'])
else:
    # מיון כללי לפי ניקוד משולב
    filtered = filtered.sort_values('combined_score', ascending=False)
4. Clustering Logic
המערכת בעצם מבצעת Content-Based Clustering - מקבצת סרטים לקבוצות לפי:
•	תוכן דומה (description keywords)
•	תכונות דומות (genre, year, runtime)
•	רמת פופולריות
זה דומה לאלגוריתמים של K-Means או Hierarchical Clustering שלמדת, אבל מותאם לחיפוש סרטים.
הטכניקות האלה יוצרות מערכת המלצות מתקדמת שמשלבת similarity measures עם clustering logic!

הצגה בכיתה:
פיתחנו צ'אטבוט חכם להמלצות סרטים שמשלב טכנולוגיות AI מתקדמות לחוויית משתמש מותאמת אישית. המערכת מבוססת על מסד נתונים של 5,371 סרטים ומשתמשת ב-Google Gemini API  לעיבוד שפה טבעית, עם תמיכה מקומית בעברית באמצעות מילוני מילות מפתח ייעודיים. הצ'אטבוט כולל מנגנון Fuzzy Matching מתקדם למניעת שגיאות הקלדה וזיהוי משמעויות, מערכת המלצות דינמית המסוגלת לסנן לפי ז'אנר, שנה, שחקנים, במאים ומילות מפתח בתיאור הסרט, וזיכרון שיחה חכם שמאפשר טיפול בשאילתות המשך הקשריות. לדוגמה, כאשר משתמש שואל "איזה סרטים טובים לילדים?" ולאחר מכן "רק רומנטיים", המערכת מבינה שהכוונה לסרטים רומנטיים המתאימים לילדים. המערכת כוללת גם זיהוי כוונות מתקדם לדחיית שאילתות לא-קשורות לסרטים ומנגנון הצעת חלופות כאשר לא נמצאים תוצאות מתאימות. הפרויקט מדגים יישום מעשי של למידת מכונה, עיבוד נתונים גדולים, וטכנולוגיות שיחה מתקדמות ליצירת כלי המלצה אינטליגנטי שפותר בעיות אמיתיות של חיפוש תוכן מותאם אישית.
במערכת שלנו יש NLP ב:
✓ Gemini API - מבין שאילתות באנגלית ומחלץ פרמטרים
✓ Intent Recognition - מזהה כוונות (המלצות, שאילתות לא רלוונטיות)
✓ Context Understanding - מבין שאילתות המשך בהקשר השיחה
✓ Information Extraction - מחלץ ז'אנרים, שנים, שחקנים מטקסט חופשי
✓ Natural Response Generation - יוצר תגובות טבעיות במקום רשימות יבשות

לפתח מודל AI מתקדם שיכלול צ'אטבוט אינטליגנטי להמלצות סרטים מותאמות אישית. הצ'אטבוט ישלב טכנולוגיות עיבוד שפה טבעית ולמידת מכונה כדי לזהות העדפות, לחזות דפוסי צפייה ולהמליץ על סרטים מבוססי נתונים.
משימות:
1.	קבלת ביג דאטה:
•	גיבוש מסד נתונים ממגוון מקורות על סרטים, כולל נתונים על ז'אנרים, דירוגים, שחקנים, במאים ותיאורי עלילה
•	ניקוי נתונים והכנתם לעיבוד וניתוח ע"י המודל
2.	שילוב מודלים של זיהוי דמיון בין מילים, CLUSTERING, או המלצות:
•	פיתוח מנגנון לזיהוי דמיון והקבצה של סרטים דומים כדי להבין העדפות משתמשים
•	שילוב מערכת המלצות מתקדמת על פי העדפות אישיות וסרטים שנצפו בעבר
3.	שילוב כלי AI לאיתור דפוסים, מגמות, ערך נוסף, אנומליות:
•	הטמעת אלגוריתמים לזיהוי העדפות חבויות ומגמות צפייה חדשות
•	פיתוח מערכת שפה טבעית לניתוח שאילתות ופעולות שיחה הקשרית
רעיונות ספציפיים שמיושמים בפרויקט שלנו:
✓ ניתוח נתוני סרטים: המערכת מנתחת מסד נתונים של 5,371 סרטים עם מגוון קריטריונים לסינון מתקדם
✓ זיהוי כוונות טקסטואליות: שימוש בטכניקות NLP (Gemini API) לזיהוי כוונות משתמש ופרמטרים מתוך שפה טבעית
✓ המלצות מותאמות אישית: מנגנון המלצות דינמי על פי ז'אנר, שנה, שחקנים, במאים וקריטריונים נוספים
✓ איתור דפוסים בשיחה: זיהוי שאילתות המשך והקשר שיחה לשיפור חוויית המשתמש
✓ חיזוי העדפות: המערכת לומדת מהשיחה ומתאימה המלצות עתידיות
האם הצ'אט עונה על הדרישות?
כן, המערכת שלנו עונה על כל הדרישות האקדמיות:
1.	✓ Big Data Processing: עיבוד מסד נתונים גדול של סרטים עם ניקוי ועיבוד מתקדם
2.	✓ Similarity & Clustering: זיהוי דמיון באמצעות Fuzzy Matching וקיבוץ על פי ז'אנרים וקריטריונים
3.	✓ AI Pattern Recognition: זיהוי דפוסים בשאילתות, מגמות בהעדפות ואנומליות בבקשות
4.	✓ NLP Integration: עיבוד שפה טבעית מתקדם עם Gemini API
5.	✓ Conversational AI: מערכת שיחה הקשרית מתקדמת עם זיכרון שיחה
6.	✓ Recommendation Engine: מנגנון המלצות מתוחכם עם סינון רב-קריטריוני
המערכת מדגימה שימוש מעשי בטכנולוגיות AI מתקדמות לפתרון בעיות אמיתיות - במקרה שלנו, מציאת סרטים מותאמים אישית באמצעות שיחה טבעית.

Similarity Matching (מדידת דמיון)
מערכת ההמלצות מיישמת טכניקות מתקדמות למדידת דמיון בין טקסטים ותוכן, המבוססות על אלגוריתמים שלמדת בקורס. הטכניקה המרכזית היא Fuzzy String Matching, המשתמשת באלגוריתם SequenceMatcher לחישוב דמיון בין מחרוזות על בסיס המרחק הלווינשטיין (Levenshtein Distance). זה מאפשר למערכת לזהות טעויות כתיב ווריאציות של אותה מילה - למשל, "romantic", "rommantic", או "romence" יזוהו כמילה זהה. בנוסף, המערכת מיישמת Content-Based Similarity Search שמנתח את תיאורי הסרטים ומחפש התאמות עם מילות המפתח של המשתמש. הטכניקה הזו דומה ל-TF-IDF (Term Frequency-Inverse Document Frequency) שבה כל מילת מפתח מקבלת ניקוד, ומילים שמופיעות במספר סרטים מקבלות ניקוד גבוה יותר. המערכת גם מיישמת Semantic Similarity באמצעות Gemini AI, שמבין את המשמעות של השאילתה ולא רק התאמות מילוליות.

Feature-Based Clustering (קיבוץ לפי תכונות)
המערכת מבצעת קיבוץ דינמי של סרטים לקבוצות על בסיס תכונות רב-ממדיות, בדומה לאלגוריתמי K-Means ו-Hierarchical Clustering שלמדת. כל סרט מאופיין בווקטור של תכונות: ז'אנר, שנת הפקה, קהל יעד, זמן ריצה, מדינת מקור, שחקנים, במאי, ותוכן התיאור. המערכת מיישמת Multi-Dimensional Filtering שמאפשר סינון ברמות שונות של דיוק - מחיפוש כללי לפי ז'אנר בלבד, ועד לחיפוש מורכב שמשלב מספר תכונות. הקיבוץ מתבצע באמצעות Combined Scoring Algorithm שמשקלל בין פופולריות הסרט (70%) לבין עדכניותו (30%), ויוצר ניקוד משולב לכל סרט. המערכת גם מיישמת Adaptive Clustering - בחיפושים ספציפיים (עם מילות מפתח) היא נותנת עדיפות לרלוונטיות התוכן, ובחיפושים כלליים היא מתמקדת בפופולריות ואיכות. זה דומה לטכניקות של Contextual Clustering שבהן האלגוריתם מתאים עצמו לסוג השאילתה ולהקשר הספציפי.
