import os
import json
import uuid
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any
from dataclasses import dataclass
from abc import ABC, abstractmethod

import pandas as pd
import google.generativeai as genai
from flask import Flask, render_template, request, jsonify, session
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address


# Configuration class for better settings management
@dataclass
class Config:
    SECRET_KEY: str = 'movie_recommender_secret_key_2024'
    CSV_FILE_PATH: str = "attached_assets/MergeAndCleaned_Movies.csv"
    GEMINI_MODEL: str = 'gemini-1.5-flash'
    MAX_CONVERSATION_HISTORY: int = 20
    DEFAULT_MOVIES_LIMIT: int = 6
    RATE_LIMIT: str = "100 per hour"
    LOG_LEVEL: str = "INFO"


# Setup logging
def setup_logging(level: str = "INFO"):
    logging.basicConfig(
        level=getattr(logging, level),
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        handlers=[
            logging.FileHandler('movie_chatbot.log'),
            logging.StreamHandler()
        ]
    )
    return logging.getLogger(__name__)


# Custom exceptions
class MovieBotException(Exception):
    """Base exception for MovieBot"""
    pass


class DataLoadException(MovieBotException):
    """Raised when data loading fails"""
    pass


class APIException(MovieBotException):
    """Raised when API calls fail"""
    pass


# Abstract base class for AI services
class AIService(ABC):
    @abstractmethod
    def generate_content(self, prompt: str) -> str:
        pass


# Gemini AI Service implementation
class GeminiService(AIService):
    def __init__(self, api_key: Optional[str], model: str):
        self.logger = logging.getLogger(__name__)
        self.model = None
        
        if api_key:
            try:
                genai.configure(api_key=api_key)
                self.model = genai.GenerativeModel(model)
                self.logger.info("Gemini API initialized successfully")
            except Exception as e:
                self.logger.error(f"Failed to initialize Gemini: {e}")
                raise APIException(f"Gemini initialization failed: {e}")
        else:
            self.logger.warning("No Gemini API key provided")
    
    def generate_content(self, prompt: str) -> str:
        if not self.model:
            raise APIException("Gemini model not available")
        
        try:
            response = self.model.generate_content(prompt)
            return response.text.strip()
        except Exception as e:
            self.logger.error(f"Gemini API call failed: {e}")
            raise APIException(f"Content generation failed: {e}")
    
    def is_available(self) -> bool:
        return self.model is not None


# Data validation and cleaning utilities
class DataValidator:
    @staticmethod
    def validate_movie_data(df: pd.DataFrame) -> pd.DataFrame:
        """Validate and clean movie data"""
        required_columns = ['name', 'genre', 'released', 'popular']
        missing_columns = [col for col in required_columns if col not in df.columns]
        
        if missing_columns:
            raise DataLoadException(f"Missing required columns: {missing_columns}")
        
        # Clean data
        df = df.dropna(subset=['name'])
        df['released'] = pd.to_numeric(df['released'], errors='coerce')
        df['popular'] = pd.to_numeric(df['popular'], errors='coerce')
        
        # Remove invalid years and ratings
        df = df[(df['released'] >= 1900) & (df['released'] <= 2030)]
        df = df[(df['popular'] >= 1) & (df['popular'] <= 5)]
        
        return df


# Enhanced conversation memory management
class ConversationMemory:
    def __init__(self, max_history: int = 20):
        self.memory: Dict[str, List[Dict]] = {}
        self.max_history = max_history
        self.logger = logging.getLogger(__name__)
    
    def add_conversation(self, user_id: str, user_query: str, response: str):
        """Add conversation to memory with automatic cleanup"""
        if user_id not in self.memory:
            self.memory[user_id] = []
        
        self.memory[user_id].append({
            'timestamp': datetime.now().isoformat(),
            'user_query': user_query,
            'response': response
        })
        
        # Keep only recent conversations
        if len(self.memory[user_id]) > self.max_history:
            self.memory[user_id] = self.memory[user_id][-self.max_history:]
    
    def get_context(self, user_id: str, context_length: int = 3) -> str:
        """Get recent conversation context"""
        if user_id not in self.memory or not self.memory[user_id]:
            return ""
        
        recent_conversations = self.memory[user_id][-context_length:]
        context = "Recent conversation:\n"
        
        for conv in recent_conversations:
            context += f"User: {conv['user_query']}\n"
            context += f"Assistant: {conv['response'][:150]}...\n\n"
        
        return context
    
    def clear_conversation(self, user_id: str):
        """Clear conversation history for user"""
        if user_id in self.memory:
            self.memory[user_id] = []
            self.logger.info(f"Cleared conversation for user {user_id}")


# Enhanced parameter extraction with caching
class ParameterExtractor:
    def __init__(self, ai_service: AIService):
        self.ai_service = ai_service
        self.logger = logging.getLogger(__name__)
        self._cache = {}  # Simple cache for repeated queries
    
    def extract_parameters(self, query: str, context: str = "") -> Dict[str, Any]:
        """Extract parameters from query with AI assistance"""
        cache_key = f"{query}_{hash(context)}"
        
        if cache_key in self._cache:
            self.logger.debug("Using cached parameters")
            return self._cache[cache_key]
        
        try:
            if self.ai_service.is_available():
                params = self._extract_with_ai(query, context)
            else:
                params = self._extract_basic(query, context)
            
            self._cache[cache_key] = params
            return params
            
        except Exception as e:
            self.logger.error(f"Parameter extraction failed: {e}")
            return self._extract_basic(query, context)
    
    def _extract_with_ai(self, query: str, context: str) -> Dict[str, Any]:
        """Extract parameters using AI"""
        system_prompt = self._get_system_prompt()
        
        context_info = f"\n\nPrevious conversation context:\n{context}\n" if context else ""
        prompt = f"{system_prompt}{context_info}\nUser query: {query}"
        
        response = self.ai_service.generate_content(prompt)
        
        # Clean JSON response
        if response.startswith('```json'):
            response = response[7:-3].strip()
        elif response.startswith('```'):
            response = response[3:-3].strip()
        
        return json.loads(response)
    
    def _extract_basic(self, query: str, context: str) -> Dict[str, Any]:
        """Fallback parameter extraction without AI"""
        return {
            'age_group': self._extract_age_group(query),
            'genre': self._extract_genre(query),
            'year_range': self._extract_year_range(query),
            'description_keywords': self._extract_keywords(query),
            'intent': 'recommend'
        }
    
    def _extract_age_group(self, query: str) -> Optional[str]:
        """Extract age group from query"""
        query_lower = query.lower()
        if any(indicator in query_lower for indicator in ['for kids', 'children', 'family']):
            return 'Kids'
        return None
    
    def _extract_genre(self, query: str) -> Optional[str]:
        """Extract genre from query"""
        genre_keywords = {
            'Romance': ['romance', 'romantic', 'רומנטי'],
            'Action': ['action', 'אקשן', 'פעולה'],
            'Comedy': ['comedy', 'funny', 'קומדיה'],
            'Drama': ['drama', 'דרמה'],
            'Horror': ['horror', 'scary', 'אימה']
        }
        
        query_lower = query.lower()
        for genre, keywords in genre_keywords.items():
            if any(keyword in query_lower for keyword in keywords):
                return genre
        return None
    
    def _extract_year_range(self, query: str) -> Optional[List[int]]:
        """Extract year range from query"""
        import re
        year_match = re.search(r'\b(19|20)(\d{2})\b', query)
        if year_match:
            year = int(year_match.group(0))
            return [year, year]
        return None
    
    def _extract_keywords(self, query: str) -> Optional[List[str]]:
        """Extract description keywords"""
        query_lower = query.lower()
        if 'about' in query_lower:
            start_pos = query_lower.find('about') + 5
            remaining = query[start_pos:].strip()
            words = [word for word in remaining.split() if len(word) > 2]
            return words[:5] if words else None
        return None
    
    def _get_system_prompt(self) -> str:
        """Get the system prompt for AI parameter extraction"""
        return """You are a movie recommendation assistant that extracts search parameters from natural language queries.

IMPORTANT: Handle Hebrew text, English text, mixed Hebrew-English, and typos. Be extremely flexible with genre recognition and spelling variations.

CONTEXT HANDLING: When analyzing the current query, consider the previous conversation context to understand:
- Follow-up questions (e.g., "only from 2019" after asking for kids movies)
- Refinements (e.g., "something newer" or "more recent")
- Continuations (e.g., "and also" or "what about")
- References to previous recommendations

Extract the following information from the user's query and return as JSON:
- age_group: target age group ONLY if explicitly mentioned (Kids, Teens, Young Adults, Adults) - if not mentioned, use null
- genre: specific genre ONLY if explicitly mentioned - if not mentioned, use null
- year_range: [min_year, max_year] ONLY if years are explicitly mentioned - if not mentioned, use null
- popular: ONLY if user explicitly asks for popular/top movies (high, medium, low) - if not mentioned, use null
- description_keywords: array of keywords describing plot/story elements - if no plot description, use null
- intent: the main intent (recommend, check_suitability, filter, general_movie_question, off_topic)

Return JSON format only."""


# Enhanced movie filtering with better performance
class MovieFilter:
    def __init__(self, movies_df: pd.DataFrame):
        self.movies = movies_df
        self.logger = logging.getLogger(__name__)
    
    def filter_movies(self, params: Dict[str, Any], limit: int = 6) -> pd.DataFrame:
        """Filter movies based on parameters with optimized performance"""
        filtered = self.movies.copy()
        self.logger.info(f"Starting with {len(filtered)} movies")
        
        # Apply filters in order of selectivity (most selective first)
        if params.get('description_keywords'):
            filtered = self._filter_by_keywords(filtered, params['description_keywords'])
        
        if params.get('genre'):
            filtered = self._filter_by_genre(filtered, params['genre'])
        
        if params.get('year_range'):
            filtered = self._filter_by_year_range(filtered, params['year_range'])
        
        if params.get('age_group'):
            filtered = self._filter_by_age_group(filtered, params['age_group'])
        
        # Sort and return top results
        return self._sort_and_limit(filtered, params, limit)
    
    def _filter_by_keywords(self, df: pd.DataFrame, keywords: List[str]) -> pd.DataFrame:
        """Filter by description keywords"""
        if 'description' not in df.columns:
            return df
        
        df = df.copy()
        df['keyword_score'] = 0
        
        for keyword in keywords:
            if len(keyword) > 2:
                mask = df['description'].str.contains(keyword, case=False, na=False)
                df.loc[mask, 'keyword_score'] += 1
        
        return df[df['keyword_score'] > 0]
    
    def _filter_by_genre(self, df: pd.DataFrame, genre: str) -> pd.DataFrame:
        """Filter by genre with flexible matching"""
        genre_mapping = {
            'romance': 'romantic',
            'romantic': 'romantic',
            'action': 'action',
            'comedy': 'comedies',
            'drama': 'dramas'
        }
        
        search_genre = genre_mapping.get(genre.lower(), genre.lower())
        return df[df['genre'].str.contains(search_genre, case=False, na=False)]
    
    def _filter_by_year_range(self, df: pd.DataFrame, year_range: List[int]) -> pd.DataFrame:
        """Filter by year range"""
        if len(year_range) == 2:
            min_year, max_year = year_range
            return df[(df['released'] >= min_year) & (df['released'] <= max_year)]
        return df
    
    def _filter_by_age_group(self, df: pd.DataFrame, age_group: str) -> pd.DataFrame:
        """Filter by age group"""
        if 'age_group' in df.columns:
            return df[df['age_group'] == age_group]
        return df
    
    def _sort_and_limit(self, df: pd.DataFrame, params: Dict[str, Any], limit: int) -> pd.DataFrame:
        """Sort results and limit to top N"""
        if df.empty:
            return df
        
        # Sort by relevance score if available, otherwise by popularity
        if 'keyword_score' in df.columns:
            df = df.sort_values(['keyword_score', 'popular', 'released'], 
                              ascending=[False, False, False])
        else:
            df = df.sort_values(['popular', 'released'], ascending=[False, False])
        
        return df.head(limit)


# Enhanced response generator
class ResponseGenerator:
    def __init__(self, ai_service: AIService):
        self.ai_service = ai_service
        self.logger = logging.getLogger(__name__)
    
    def generate_response(self, movies: pd.DataFrame, params: Dict[str, Any], 
                         original_query: str) -> str:
        """Generate appropriate response based on context"""
        if movies.empty:
            return self._generate_no_results_response(params)
        
        if self._is_analytical_question(original_query):
            return self._generate_analytical_response(movies, original_query)
        else:
            return self._generate_recommendation_response(movies, params)
    
    def _is_analytical_question(self, query: str) -> bool:
        """Check if query requires analysis vs new search"""
        analytical_keywords = ['which', 'what', 'how', 'tell me about', 'recommend', 'best']
        return any(keyword in query.lower() for keyword in analytical_keywords)
    
    def _generate_analytical_response(self, movies: pd.DataFrame, query: str) -> str:
        """Generate analytical response using AI or fallback"""
        try:
            if self.ai_service.is_available():
                return self._generate_ai_analysis(movies, query)
            else:
                return self._generate_basic_analysis(movies, query)
        except Exception as e:
            self.logger.error(f"Analysis generation failed: {e}")
            return self._generate_basic_analysis(movies, query)
    
    def _generate_ai_analysis(self, movies: pd.DataFrame, query: str) -> str:
        """Generate AI-powered analysis"""
        movies_data = []
        for _, movie in movies.head(5).iterrows():
            movies_data.append({
                'title': movie['name'],
                'year': int(movie['released']) if pd.notna(movie['released']) else 'Unknown',
                'genre': movie['genre'] if pd.notna(movie['genre']) else 'Unknown',
                'rating': movie['popular'] if pd.notna(movie['popular']) else 'Unknown'
            })
        
        prompt = f"""You are a helpful movie recommendation assistant. The user asked: "{query}"

Here are the relevant movies:
{movies_data}

Provide a brief, friendly response (2-3 sentences max). Be helpful and conversational."""
        
        return self.ai_service.generate_content(prompt)
    
    def _generate_basic_analysis(self, movies: pd.DataFrame, query: str) -> str:
        """Generate basic analysis without AI"""
        if len(movies) == 1:
            movie = movies.iloc[0]
            year = int(movie['released']) if pd.notna(movie['released']) else 'Unknown'
            return f"I'd recommend \"{movie['name']}\" ({year}) - it's a great choice!"
        else:
            return f"I found {len(movies)} great movies for you. They all have good ratings and match your preferences."
    
    def _generate_recommendation_response(self, movies: pd.DataFrame, params: Dict[str, Any]) -> str:
        """Generate movie recommendation list"""
        intro = self._generate_intro(params)
        
        response = intro + "\n\n"
        for i, (_, movie) in enumerate(movies.iterrows(), 1):
            year = int(movie['released']) if pd.notna(movie['released']) else 'Unknown'
            genre = movie['genre'] if pd.notna(movie['genre']) else 'Unknown'
            rating = movie['popular'] if pd.notna(movie['popular']) else 'N/A'
            
            response += f"{i}. **{movie['name']}** ({year})\n"
            response += f"   Genre: {genre} | Rating: {rating}/5\n\n"
        
        return response.strip()
    
    def _generate_intro(self, params: Dict[str, Any]) -> str:
        """Generate contextual intro based on parameters"""
        criteria = []
        if params.get('genre'):
            criteria.append(f"{params['genre'].lower()} movies")
        if params.get('age_group'):
            criteria.append(f"suitable for {params['age_group'].lower()}")
        if params.get('year_range'):
            criteria.append(f"from {params['year_range'][0]}-{params['year_range'][1]}")
        
        if criteria:
            return f"Here are some great {' and '.join(criteria)}:"
        else:
            return "Here are some movie recommendations for you:"
    
    def _generate_no_results_response(self, params: Dict[str, Any]) -> str:
        """Generate response when no movies found"""
        return "I couldn't find any movies matching your specific criteria. Try broadening your search or asking for different genres, years, or themes."


# Main MovieRecommender class - simplified and improved
class MovieRecommender:
    def __init__(self, config: Config):
        self.config = config
        self.logger = setup_logging(config.LOG_LEVEL)
        
        # Initialize components
        self.ai_service = self._initialize_ai_service()
        self.movies = self._load_movies()
        self.memory = ConversationMemory(config.MAX_CONVERSATION_HISTORY)
        self.parameter_extractor = ParameterExtractor(self.ai_service)
        self.movie_filter = MovieFilter(self.movies)
        self.response_generator = ResponseGenerator(self.ai_service)
        
        self.logger.info("MovieRecommender initialized successfully")
    
    def _initialize_ai_service(self) -> AIService:
        """Initialize AI service"""
        api_key = os.environ.get('GEMINI_API_KEY')
        return GeminiService(api_key, self.config.GEMINI_MODEL)
    
    def _load_movies(self) -> pd.DataFrame:
        """Load and validate movie data"""
        try:
            encodings = ['utf-8', 'latin-1', 'cp1252', 'iso-8859-1']
            
            for encoding in encodings:
                try:
                    movies = pd.read_csv(self.config.CSV_FILE_PATH, encoding=encoding)
                    movies = DataValidator.validate_movie_data(movies)
                    self.logger.info(f"Successfully loaded {len(movies)} movies with {encoding} encoding")
                    return movies
                except (UnicodeDecodeError, FileNotFoundError):
                    continue
            
            raise DataLoadException("Could not load CSV file with any encoding")
            
        except Exception as e:
            self.logger.error(f"Failed to load movie data: {e}")
            raise DataLoadException(f"Error loading movie data: {e}")
    
    def get_recommendation(self, user_id: str, query: str) -> str:
        """Main method to get movie recommendations"""
        try:
            # Handle special commands
            if query == '__RESET_CONVERSATION__':
                self.memory.clear_conversation(user_id)
                return "Conversation reset successfully! How can I help you find movies today?"
            
            # Check for off-topic queries
            if self._is_off_topic(query):
                return "I specialize in movie recommendations! Please ask me about films, actors, genres, or anything movie-related."
            
            # Get conversation context
            context = self.memory.get_context(user_id)
            
            # Extract parameters
            params = self.parameter_extractor.extract_parameters(query, context)
            
            # Filter movies
            filtered_movies = self.movie_filter.filter_movies(params, self.config.DEFAULT_MOVIES_LIMIT)
            
            # Generate response
            response = self.response_generator.generate_response(filtered_movies, params, query)
            
            # Save conversation
            self.memory.add_conversation(user_id, query, response)
            
            return response
            
        except Exception as e:
            self.logger.error(f"Error processing recommendation request: {e}")
            return "I encountered an error while processing your request. Please try again with a different query."
    
    def _is_off_topic(self, query: str) -> bool:
        """Check if query is off-topic"""
        off_topic_keywords = ['weather', 'politics', 'cooking', 'sports', 'news', 'health', 'travel']
        query_lower = query.lower()
        return any(keyword in query_lower for keyword in off_topic_keywords)


# Flask application setup
def create_app(config: Config = None) -> Flask:
    """Create and configure Flask app"""
    if config is None:
        config = Config()
    
    app = Flask(__name__, static_folder='.', template_folder='.')
    app.secret_key = config.SECRET_KEY
    
    # Setup rate limiting
    limiter = Limiter(
        app,
        key_func=get_remote_address,
        default_limits=[config.RATE_LIMIT]
    )
    
    # Initialize recommender
    recommender = MovieRecommender(config)
    
    @app.route('/')
    def index():
        return render_template('index.html')
    
    @app.route('/recommend', methods=['POST'])
    @limiter.limit("20 per minute")
    def recommend():
        try:
            data = request.get_json()
            query = data.get('query', '').strip()
            
            if not query:
                return jsonify({'error': 'No query provided'}), 400
            
            # Get or create user ID
            user_id = session.get('user_id')
            if not user_id:
                user_id = str(uuid.uuid4())
                session['user_id'] = user_id
            
            # Get recommendation
            recommendation = recommender.get_recommendation(user_id, query)
            
            return jsonify({'recommendation': recommendation})
            
        except Exception as e:
            app.logger.error(f"Error in recommend endpoint: {e}")
            return jsonify({'error': 'An error occurred processing your request'}), 500
    
    @app.route('/health')
    def health_check():
        return jsonify({'status': 'healthy', 'timestamp': datetime.now().isoformat()})
    
    return app


# Main execution
def main():
    """Main function to run the application"""
    config = Config()
    app = create_app(config)
    
    print("=" * 50)
    print("Enhanced Movie Recommendation Chatbot")
    print("=" * 50)
    print("Open your browser and go to: http://localhost:5000")
    
    app.run(host='0.0.0.0', port=5000, debug=False)


if __name__ == '__main__':
    main()